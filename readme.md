# 분산 트랜잭션 (Distributed Transaction)

분산 환경에서 **여러 서비스 혹은 데이터베이스 간 트랜잭션 원자성(Atomicity)** 보장을 위한 설계 패턴.  
대표 패턴: **2PC**, **TCC**, **SAGA**

---

## 1. Two-Phase Commit (2PC)

### 개념
- 전통적 분산 트랜잭션 프로토콜
- 트랜잭션을 **Prepare 단계**와 **Commit 단계**로 구분
- Coordinator가 모든 참여 노드 조율
- **ACID 완전 보장**

---

### 절차
1. **Prepare Phase**
    - Coordinator → 각 참여자에게 준비 요청
    - 모든 참여자 OK 응답 시 다음 단계 진행
2. **Commit Phase**
    - 모두 OK 시 commit, 일부 실패 시 rollback 명령

---

### 장점
- 강한 일관성(Strong Consistency) 보장
- ACID 완전 지원
- XA 지원 DB 사용 시 구현 용이
- 구현 로직 단순

---

### 단점
- **Blocking 문제**: Prepare 이후 Lock 유지
- **단일 장애점(SPOF)**: Coordinator 장애 시 전체 중단
- **성능 저하**: 동기 처리로 인한 지연
- **확장성 제한**: 참여자 증가 시 성능 저하
- **장애 복구 난이도**: 수동 개입 필요

---

### 적용 사례
- 금융 시스템: 계좌 이체 (출금 + 입금)
- B2B 재고/주문 시스템: 낮은 트래픽, 높은 정합성 요구
- 레거시 통합: 모놀리식 ↔ 신규 MSA 연동

---

## 2. Try-Confirm-Cancel (TCC)

### 개념
- **비즈니스 레벨 2PC 확장 패턴**
- 각 서비스가 **Try**, **Confirm**, **Cancel** 단계 구현
- DB Lock 대신 **예약(Reservation)** 기반 처리
- 강한 정합성 필요 영역에 제한적 사용

---

### 절차
1. **Try 단계** → 자원 예약
2. **Confirm 단계** → 실제 확정
3. **Cancel 단계** → 실패 시 예약 해제

---

### 장점
- DB Lock 점유 시간 최소화
- 2PC 대비 성능·확장성 우위
- 장애 복구 및 재시도 전략 유연
- 비즈니스 정책 기반 제어 가능

---

### 단점
- 구현 복잡도 증가 (3단계 메서드 필요)
- 멱등성(Idempotency) 필수
- 중간 상태(Pending) 관리 필요
- 운영 비용 증가

---

### 실패 처리 전략
- **확정 중 오류** → Pending 상태 유지 후 수동/자동 복구
- **예약 실패** → 일부 자원 미취소 가능, 각 서비스 자율 정리

---

### 적용 사례
- 호텔/항공권 예약
    - Try: 좌석 임시 예약
    - Confirm: 결제 확정
    - Cancel: 실패 시 해제
- 이커머스 주문
    - Try: 재고·포인트·쿠폰 예약
    - Confirm: 결제 확정
    - Cancel: 결제 실패 시 해제
- 티켓팅 시스템
    - 동시성 제어 및 임시 예약 필요

---

## 3. SAGA 패턴

### 개념
- **로컬 트랜잭션의 연속 처리 패턴**
- 각 단계 성공 시 다음 단계 진행, 실패 시 **보상 트랜잭션(Compensation)** 실행
- **즉시 상태 변경**, **최종 일관성(Eventual Consistency)** 보장
- 리소스 예약 없이 실행

---

### 특징
- 각 서비스 → 자체 로컬 트랜잭션 수행
- 실패 시 보상 트랜잭션 실행
- 멱등성 필수 (중복 호출 대비)

---

### 구현 방식

#### Orchestration (조율형)
- 중앙 **Orchestrator** 가 전체 트랜잭션 흐름 제어
- 각 서비스는 요청에 응답만 수행

**장점**
- 흐름 명확 / 모니터링 용이
- 조건 분기, 병렬 처리 가능
- 서비스 간 결합도 낮음

**단점**
- Orchestrator 단일 장애점 (SPOF)
- 로직 집중으로 인한 복잡도 증가
- 순차 처리로 인한 지연 발생

**적용 사례**
- 복잡한 주문 프로세스
- 여행 예약 (항공 + 호텔 + 렌터카)
- 대출 심사 (신용조회 → 승인 절차)

---

#### Choreography (이벤트 기반)
- Orchestrator 없이 **각 서비스 간 이벤트 발행/구독**
- **Event-Driven Architecture(EDA)** 기반

**장점**
- 느슨한 결합
- 단일 장애점 없음
- 서비스 확장 용이
- 병렬 처리 가능

**단점**
- 이벤트 플로우 추적 어려움
- 순환 의존성 위험
- 테스트·디버깅 난이도 높음
- 전체 상태 파악 어려움

**적용 사례**
- EDA 기반 MSA 구조
- 단순 워크플로우 (3~4단계)
- 소셜미디어 피드, 통계 업데이트

---

## 패턴 비교

| 구분 | 2PC | TCC | SAGA |
|------|-----|-----|------|
| 일관성 | 강한 일관성 | 강한 일관성 | 최종 일관성 |
| 구현 난이도 | 낮음 (XA 지원 시) | 매우 높음 | 중간 |
| 성능 | 낮음 (Lock 유지) | 중간 | 높음 |
| 확장성 | 낮음 | 중간 | 높음 |
| 장애 복구 | 수동 개입 필요 | 유연 | 자동 가능 |
| 사용 사례 | 금융·레거시 | 결제·예약 | 대용량 MSA |
| 단위 | DB 트랜잭션 | 비즈니스 트랜잭션 | 서비스 트랜잭션 |

---

## 실무 선택 기준

| 시스템 유형 | 권장 패턴 | 선택 이유 |
|--------------|------------|------------|
| 금융 / 결제 | 2PC → TCC | 데이터 정합성 최우선 |
| 이커머스 | TCC → SAGA(Orchestration) | 복잡한 보상 트랜잭션 대응 |
| 대용량 트래픽 | SAGA(Choreography) | 성능·확장성 중심 |
| 레거시 통합 | 2PC | 기존 시스템 호환성 확보 |

---

## 구현 가이드

### 보상 트랜잭션 설계 원칙
- 멱등성 보장
- 타임아웃 설정
- 재시도 전략 구성
- 전체 단계 로깅 및 모니터링

---

### SAGA 구현 주의사항
- 이벤트 순서 보장 → **Kafka Partition Key** 활용
- 중복 메시지 처리 → **멱등성 키** 사용
- **Dead Letter Queue (DLQ)** 구성
- 보상 이벤트 버전 관리

---

### 상태 관리 전략

| 패턴 | 상태 주체 | 저장소 예시 |
|-------|-------------|--------------|
| Orchestration | Orchestrator | Redis, RDB, DynamoDB |
| Choreography | 각 서비스 개별 | Kafka, Redis, Event Store |

---

## 결론

| 선택 기준 | 권장 패턴 |
|------------|------------|
| 강한 정합성 / 단일 트랜잭션 중심 | **2PC** |
| 정합성 + 성능 균형 / 예약 기반 트랜잭션 | **TCC** |
| 성능·확장성 우선 / 최종 일관성 허용 | **SAGA** |